API
===

Введение
--------

Обычно программы для автоматических систем управлений разрабатываются на специализированных контроллерах с использованием
IEC-61131 языков программирования (например мы очень долго применяли WAGO 750-8xx, великолепный контроллер). 

Языки IEC во всех контроллерах почти не отличаются, есть объектно-ориентированные варианты. Мы предлагаем попробовать другой 
подход: разработка программ на python (его форк для микроконтроллеров micropython), используя библиотеку PYPLC.

Чтобы переход от IEC-61131 был более легким на python мы постарались приблизить внешне код к этим языкам (LD,SFC,STL).
Язык FBD в этот список пока не входит.

Среда программирования - редактор VSCode, очень шустрая, изящная и многоплатформенная. Интеграция с GIT - отдельное удовольствие. 

Структура программы
-------------------

Логика управления - это циклически выполняемая программа. Тоесть код написанный разработчиком выполняется через определенный интервал, например
КОД РАЗРАБОТЧИКА - ОПРОС УСТРОЙСТВ ВВОДА-ВЫВОДА - КОД РАЗРАБОТЧИКА ... и так по кругу. 

Чтобы это сделать с использованием PYPLC необходимо написать то что должен делать КОД РАЗРАБОТЧИКА в виде функции или генератора или потомка одного
из классов библиотеки (POU,STL,SFC,LD) и передать его в качестве параметра методу :py:meth:`pyplc.core.PYPLC.run`. Это и будет бесконечная циклическая
программа.

Минимальный пример программы
----------------------------

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   
   def user_prog():
      pass

   plc.run(instances=[user_prog],ctx=globlas())

Это пример логики, которая ничего не делает (user_prog содержит пустую инструкцию pass). Она будет выполняться периодически (по умолчанию каждые 100 мсек).

Этот код должен быть в файле с расширением .py. Он может быть выполнен как в python 3.10 на ПК, так и на контроллере. При написании редко попадается задача,
которую удобно реализовать в виде функции без использования предыдущих состояний. Тут может пригодится механизм генераторов python

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   
   def user_prog():
      print('тик')
      yield 
      print('так')
      yield

   plc.run(instances=[user_prog],ctx=globlas())

Используя ключевое слово yield функция как бы заканчивает свою работу в этот цикл, а при следующем вызове продолжит со следущей строки за yield. Получится
в первый цикл работы user_prog напишет 'тик', во второй цикл работы напишет 'так', затем снова 'тик' и так без конца.

Усложним задачу: каждый 20 раз выведем 'бом' 

.. highlight:: python
.. code-block:: python

   def user_prog():
      for _ in range(0,10):
         print('тик')
         yield 
         print('так')
         yield
      print('бом')
      yield

Обратите внимание, что если забыть yield в цикле for, то логика изменится: функция выведет 'тик' 'так' 10 раз за один вызов. 
Тоесть при написании можно считать, что ключевое слово yield производит опрос модулей ввода вывода.

Основным классом, который нужен для реализации циклической программы выступает :py:class:`PYPLC`, но на практике его явно 
создавать не нужно, так как это неявно происходит в :py:mod:`pyplc.config`. 

При этом в коде для доступа к каналам ввода-вывода используется экземпляр PYPLC:

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc # plc - экземпляр PYPLC

   if plc.MIXER_ISON():
      plc.MIXER_ON(False)

и для запуска цикла программы

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc # plc - экземпляр PYPLC

   # тут будет ваша логика и подготовка к работе ...

   plc.run(instances=[<пользовательские функции>],ctx=globlas()) #запускаем логику
   '''
   где <пользовательские функции> - через запятую функции, которые надо вызывать каждый
   цикл работы программы
   '''

.. automodule:: pyplc.core

   class PYPLC
   ===========
   .. autoclass:: PYPLC
      :members:
      :undoc-members: 

.. automodule:: pyplc.ld

   .. rubric:: Классы

   .. autosummary::
   
      Cell
      LD

   class Cell
   ===========
   .. autoclass:: Cell
      :members:

   class LD
   ===========
   .. autoclass:: LD
      :members:

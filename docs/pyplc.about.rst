Введение
========

Термины и обозначения
---------------------
ПЛК - программируемый логический контроллер.

Логика управления - программа для специализированного оборудования (программируемые контроллеры), которая выполняет управление 
промышленным оборудованием.

SCADA (аббр. от англ. Supervisory Control And Data Acquisition — диспетчерское управление и сбор данных) — программный пакет, 
предназначенный для разработки или обеспечения работы в реальном времени систем сбора, обработки, отображения и архивирования 
информации об объекте мониторинга или управления.

callback  (англ. call — вызов, англ. back — обратный) или функция обратного вызова в программировании — передача исполняемого кода 
в качестве одного из параметров другому коду. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове. 
Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. 
Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), 
которые естественным образом задаются как обратные вызовы. (`страница на wikipedia <https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>`_)

Общая информация
----------------

PYPLC - библиотека для разработки и отладки логики управления на языке программирования micropython/python для контроллеров KRAX-PLC932.
Цель библиотеки - сделать программирование контроллера на python схожим с написанием на языках программирования IEC-61131 (LD,SFC,STL),
обеспечить связь с программой визуализации (интерфейс оператора, SCADA).

Логика управления из себя представляет циклическую программу, каждый цикл которой состоит из:

- опрос модулей ввода для получения состояния измерительных каналов (аналоговых, дискертных, счетчиков импульсов)
- обработка состояний измерительных каналов и, возможно, формирование управляющих воздействий
- отправка управляющих воздействий модулям вывода (аналоговые, дискретные)

Разработка логики
=================

Чтобы сделать программирование ПЛК на python похожим на IEC-61131, используется три подхода: 

- STL - функции или потомки :py:class:`~pyplc.pou.POU`
- SFC - генераторы или потомки :py:class:`~pyplc.sfc.SFC`
- LD  - экземпляры классов из :py:mod:`pyplc.ld`.

Работа с параметрами
--------------------

Важный аспект в процессе написания программы - это передача параметров, измерительных и управляющих каналов логике и обратно. 
При разрабоке если функции необходимо передать изменяющийся параметр (например состояние датчика), то используется механизм callback
функций, тоесть вместо значения состояния датчика передавать надо функцию, которая если ее вызвать возвращает текущее состояние. 

По этой причине классы из PYPLC переопределяют специальный метод `__call__`, то позволяет использовать их экземпляры как callback
функции.

Простая программа
-----------------

Чтобы программа была похожа на STL реализуем логику как обычную функцию или как потомока  :py:class:`~pyplc.pou.POU`.

С использованием PYPLC программа выглядит так:

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   
   def user_prog():
      pass

   plc.run(instances=[user_prog],ctx=globals())

Логика здесь ничего не делает (`user_prog` содержит пустую инструкцию `pass`). Она будет выполняться периодически (по умолчанию каждые 100 мсек).
Опрос и организацию переодического запуска выполняет последняя строка, :py:meth:`~pyplc.core.PYPLC.run`. Выход из программы возможен в случае KeyboardInterrupt (Ctrl+C) либо по ошибке
в коде.

С применением :py:class:`~pyplc.pou.POU` нужно наследовать новый класс от него, переопределить метод :py:meth:`~pyplc.pou.POU.__call__`

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   from pyplc.pou import POU
   
   class UserProg(POU):
      def __call__(self):
         pass
   
   user_prog = UserProg()

   plc.run(instances=[user_prog],ctx=globals())

Классы с методом  `__call__` могут использоваться как функции: `user_prog()` произведет вызов метода `__call__` нашего класса UserProg.

Пошаговые программы
-------------------

Чтобы программа была похожа на SFC нужно написать функцию-генератор или потомок :py:class:`~pyplc.sfc.SFC`.

Удобно использовать для того чтобы написать программу, которая выполняет различные последовательности действий каждый следующий цикл сканирования.

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   
   def user_prog():
      print('тик')
      yield 
      print('так')
      yield

   plc.run(instances=[user_prog],ctx=globals())

Генератор, если сильно упрощенно - это функция, в теле которой есть ключевое слово `yield`. Если plc.run в параметре instances встечается генератор, то 
будет произведен его обход (возвращаемое значение yield игнорируется), по одному элементу за цикл, или проще говоря `user_prog` каждый цикл будет 
выполнена до следующего `yield`. В примере выше получится в первый цикл работы user_prog напишет 'тик', во второй цикл работы напишет 'так', 
затем снова 'тик' и так без конца (когда генератор кончается, он перезапускается сначала). 

С применением :py:class:`~pyplc.sfc.SFC` нужно наследовать новый класс от него, переопределить метод :py:meth:`~pyplc.sfc.SFC.main`

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   from pyplc.sfc import SFC
   
   class UserProg(SFC):
      def main(self):
         print('тик')
         yield 
         print('так')
         yield
   
   user_prog = UserProg()

   plc.run(instances=[user_prog],ctx=globals())

Многоступенчатые программы
--------------------------

Чтобы программа была похожа на LD необходимо использовать методы :py:class:`pyplc.ld.LD`. Их всего 2: `no` или `nc`. Им соответсвуют нормально открытые и нормально-закрытые контакты (contact). 
Эти методы возвращают объект :py:class:`~pyplc.ld.Cell`, которые в свою очередь имеют методы для создания контактов (contact), катушек (coil) и набор других объектов
LD логики. 

.. highlight:: python
.. code-block:: python

   from pyplc.config import plc
   from pyplc.channel import IBool,QBool
   from pyplc.ld import LD
   
   SWITCH_ON_1 = IBool.at( '%IX8.0' )
   SWITCH_OFF_1= IBool.at( '%IX8.1' )
   POWER_ON_1 = QBool.at( '%QX9.0' )

   user_prog = LD.no(SWITCH_ON_1).set(POWER_ON_1).end()

   plc.run(instances=[user_prog],ctx=globals())

Логика user_prog похожа на цепочку, начинается с `LD` заканчивается `end()`. Результат тоже может вызываться как функция и может быть передана в параметр `instances` :py:meth:`~pyplc.core.PYPLC.run`

Отладка логики
--------------

В процессе разработки программы с использованием PYPLC отладка проводится в 2 этапа: 

- Первичная, на компьютере. 
- На контроллере.

На первом этапе доступны привычные отладочные механизмы: контрольные точки, просмотр значений всех переменных и памяти. 
Ничем не отличается от отладки обычной программы на python, используется ваша любимая среда разработки (я поклонник vscode).
Используя :py:meth:`~pyplc.channel.Channel.force` можно написать логику создания имитационных значений, которую в конечном 
варианте логики не вызывать или закомментировать. Также можно настроить режим симуляции (когда логика выполняется на компьютере, но
каналы ввода-вывода обновляются на контроллере).

На втором этапе, в контроллере, доступны только просмотр значений переменных и изменение их значений. Происходит это в режиме коммандной
строки, из telnet клиента. Реализовано это при помощи :py:class:`~pyplc.utils.cli.CLI`

   .. automodule:: pyplc.utils.cli

   .. autoclass:: CLI
